
# 컬러 스페이스 

1) 바이너리 이미지
 - 한 개의 픽셀을 두가지 값으로만 표현한 이미지를 바이너리 이미지라고 한다. 두 가지 값은 0,1 또는 0, 255를 사용한다. 
 - 아주 오래전 신문 같은 인쇄물에서 사용했던 방법
 - 영상 작업에서는 피사체의 색상과 명암정보는 필요 없고 오직 피사체의 모양 정보만 필요할 때 사용한다. 
 
2) 그레이 스케일 이미지 
 - 흑백 사진 (엄밀히 따지만 흑백이미지는 바로 앞서 말한 바이너리 이미지를 말하는 것) 
 - 1개의 픽셀을 0~255의 값으로 표현, 픽셀 값의 크기로 "명암"만을 표현. 
 - 가장 작은 값 0이 가장 어두운 검은색을 의미, 값이 커질수록 밝은 색을 의미하다가 255까지가면 흰색을 나타낸다. 
 - 음수가 없는 부호없는 1바이트 크기 (uint8) 로 표현하는 것이 일반적이다. 
 - * 이미지 프로세싱에서는 색상 정보가 쓸모 없을 때 컬러 이미지의 색상 정보를 제거함으로써 "연산의 양을 줄이려고 사용"
 
3) 컬러 이미지
 - 컬러 이미지를 표현하는 방법은 다양하다. 흔히 컬러 이미지는 한 픽셀당 0~255의 값 3개를 조합해서 표현.
 - RGB, BGR, RGBA 
 - RGBA ? 배경을 투명처리하기 위해 알파(alpha)채널을 추가한 것을 말한다. (4번째 채널) 


============================================================

RGB 평균값으로 grayscale을 구하는 것이 부정확한 이유?

RGB를 Grayscale로 변환할 때 RGB의 평균값이 아닌 가중치를 둔 값으로 변환해야 한다. 
왜냐하면, 사람 눈에는 동일한 값을 가질 때 G가 가장 밝게 보이고 그 다음 R과 B가 밝게 보이기 때문이다.
즉, 이를 고려하며,
동일 수치에서 가장 돋보이는 G의 가중치는 높이고, B의 가중치는 낮춰야 GrayScale이 보다 자연스러워집니다.

L = 0.299*R + 0.587*G + 0.114*B


RGB만 있으면 모든색을 표현할 수 있는데, 왜 YUV를 사용할까?
아주 오랜 옛날(?) 이야기가 되겠지만, 이전에는 흑백 텔레비젼을 사용했다. 
흑백에서는 색깔이 중요한것이 아니라 오직 밝기만이 중요했다. 
말 그대로 흑백이니깐 말이다. 
그런데 흑백 텔레비젼만 계속 사용했으면 모르겠지만, 
얼마 후 칼라텔레비젼에 나오고 나서 문제가 생겼다. 
바로 색깔 정보를 전송해야 한다는것이다. 
그러면 색깔 정보를 다 포함한 RGB를 모두 쏴 주면 될것 아닌가? 라고 생각하겠지만
, 기존에 흑백 텔레비젼을 사용하던 사람들도 TV는 계속 잘 볼 수 있어야 할 것 아닌가?

그래서 기존에 흑백 TV들이 칼라 정보를 잘못 처리 하지 않도록 
밝기 정보는 그대로 유지해야 하는 문제가 생겼다. 
즉, 밝기 정보(Y)만을 따로 분리해서 전송하고, 
색깔 정보(U,V)는 따로 보내는 방법을 사용하게 되었다. 
그렇게해서 생겨난것이 YUV 이다.

YCbCr (ITU-R BT.709)
Y = 색의 밝기 정보 ( 기존 흑백 TV를 위한 정보 )
Cb = 색의 밝기 정보에서 파란색의 차이 ( blue-difference chroma compoents )
Cr = 색의 밝기 정보에서 빨간색의 차이 ( red-difference chroma compoents )

밝기정보, Cb, Cr 을 이용하면 실제로 보여주어야 하는 Color을 표현할 수 있다.
(녹색은 밝기정보, blue, red 정보를 이용하여 계산해 낼 수 있으므로 굳이 전송하지 않는다. )

> 결론: YUV는 밝기 정보와 컬러정보를 분리해서 사용하므로 명암 대비가 좋지않은 영상을 좋게 만드는데 대표적으로 화룡ㅇ된다.
     또한, 밝기 정도는 첫번째 Y채널에만 나타나는 것을 알 수 있다. 
	 픽셀의 밝기를 제어해야할 때 BGR 포맷은 3채널을 모두 연산해야 하지만 YUV 포맷은 Y채널 하나만 작업하면 되므로 효과적이다.

===================================================================

* HSV 사용 이유

H: 색상(Hue)
 - 픽셀이 어떤 색인지 표현. 
 - 원 위에 빨강, 노랑, 초록, 파랑을 거쳐 다시 빨강으로 돌아오는 방식으로 색상에 0~360범위의 매칭되는 값을 갖게 하여 색 표현
 - 하지만 OpenCV에서 표현할 때 배열의 dtype은 최대 값이 255를 넘지 못하므로 360을 반으로 나누어 0~180 범위의 값으로 표현

S: 채도(Saturation)
 - 해당 색상이 얼마나 순수하게 포함되어 있는지 표현. S 값은 0~255 범위로 표현, 255는 가장 순수한 색상
 
V: 명도 (Value) 
 - 빛이 얼마나 밝은지 어두운지를 표현하는 값, 0~255 범위, 255가 가장 밝은 상태. 0이 가장 어두운 상태.
 
HSV, HSL, HSI ????
 
HSL = Hue, Saturation, Lighness
HSV = Hue, Saturation, Value ( 혹은 HSB = Hue, Saturation, Brightness )
HSI = Hue, Saturation, Intensity

마지막에 명도를 표현하는 방법에 따라 종류가 나뉘는 것.

각 마지막에 있는 L, B, V, I 는 모두 밝기 정보를 나타낸다.
이때 RGB를 HSL, HSV(HSB), HSI 로 바꾸는 공식은 모두 다른데, 
이때 각 표현 방법중에서 밝기를 계산하는 공식은 다음과 같다.

L = ( Max(R,G,B)  + MIN(R,G,B) ) / 2
V(B) = Max(R, G, B)
I = ( R + G + B ) / 3  (우리가 일반적으로 생각하는 공식)

> 결론: 픽셀의 색상이 궁금할 때 RGB 포맷의 경우 3가지 채널의 값을 모두 조사해야하지만,
       HSV 포맷은 오직 H 채널 값만 확인하면 되므로 색상을 기반으로 하는 여러가지 작업에 효과적이다.
